[/
  Copyright 2020 Ilia Shirobokov.
  Copyright 2020 Alisa Cherniaeva.

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:modular_adaptor modular_adaptor]

[pre
[*Table of Contents]
 [link boost_multiprecision.tut.modular.modular_adaptor.api modular_adaptor API]
     [link boost_multiprecision.tut.modular.modular_adaptor.const_oper Constructors and Operators]
     [link boost_multiprecision.tut.modular.modular_adaptor.getter Getters]
     [link boost_multiprecision.tut.modular.modular_adaptor.members Class member functions]
        [link compare `compare(const modular_adaptor& o)`]
        [link compare_t `compare(const T& val)`]
        [link negate `negate()`]
        [link str `str(std::streamsize dig, std::ios_base::fmtflags f)`]
        [link swap `swap(modular_adaptor& o)`]
     [link boost_multiprecision.tut.modular.modular_adaptor.other Other]
        [link eval_redc `eval_redc(Backend& result, const modular_params<Backend>& mod)`]
     [link boost_multiprecision.tut.modular.modular_adaptor.backend_requirements Backend Required Functions]
        [link eval_add `eval_add(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]
        [link eval_convert_to `eval_convert_to(Result* result, const modular_adaptor<Backend>& val)`]
        [link eval_subtract `eval_subtract(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]
        [link eval_multiply `eval_multiply(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]
        [link eval_divide `eval_divide(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]
        [link eval_modulus `eval_modulus(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]
        [link eval_is_zero `eval_is_zero(const modular_adaptor<Backend>& val)`]
        [link eval_get_sign `eval_get_sign(const modular_adaptor<Backend>&)`]
        [link assign_components `assign_components(modular_adaptor<Backend>& result, const T& a, const V& b)`]
        [link eval_sqrt `eval_sqrt(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& val)`]
        [link eval_abs `eval_abs(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& val)`]
        [link window_bits `size_t window_bits(size_t exp_bits))`]
        [link find_modular_pow `find_modular_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, Backend& exp)`]
        [link eval_pow `eval_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, const modular_adaptor<Backend>& e)`]
        [link eval_pow_backend_e `eval_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, const Backend& e)`]
        [link eval_left_shift `eval_left_shift(modular_adaptor<Backend>& t, UI i)`]
        [link eval_right_shift `eval_right_shift(modular_adaptor<Backend>& t, UI i)`]
        [link eval_left_shift_with_v `eval_left_shift(modular_adaptor<Backend>& t, const modular_adaptor<Backend>& v, UI i)`]
        [link eval_right_shift_with_v `eval_right_shift(modular_adaptor<Backend>& t, const modular_adaptor<Backend>& v, UI i)`]
        [link eval_bitwise_and `eval_bitwise_and(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]
        [link eval_bitwise_or `eval_bitwise_or(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]
        [link eval_bitwise_xor `eval_bitwise_xor(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]
]

``
    namespace boost {
    namespace multiprecision {
    namespace backends {

    template <typename Backend>
    class modular_adaptor;
    }}
``
The class template `modular_adaptor` is a backend for number which converts any existing integer backend into a number backend for [@https://en.wikipedia.org/wiki/Modular_arithmetic modular arithmetic].

The class `modular_adaptor` contains two parts.

* The first part is a /number/ which is defined by the given integer backend. In math, it is known as /residue class/ or /congruence class/. 
* The second part is /modulus/ which is an instance of [link boost_multiprecision.tut.modular.modular_adaptor.modular_params `modular_params`].

[h2:api modular_adaptor API]

[h4:const_oper Constructors and Operators]

[table `modular_adaptor` constructors
    [ [ Signature ] [ Comments ] ]
    [ [ `modular_adaptor()` ] [ ] ]
    [ [ `modular_adaptor(const modular_adaptor& o)` ] [ ] ]
    [ [ `modular_adaptor(modular_adaptor&& o)` ] [ ] ]
    [ [ `modular_adaptor(const Backend& val, const modular_params<Backend>& mod)` ] [ ] ]
    [ [ `modular_adaptor(const Backend& val, const Backend& mod)` ] [ ] ]
    [ [ `modular_adaptor(Backend& val, Backend& mod)` ] [ ] ]
    [ [ `modular_adaptor(const Backend& val)` ] [ ] ]
    [ [ `modular_adaptor(const modular_params<Backend>& mod)` ] [ ] ]
]

[table `modular_adaptor` operators
    [ [ Signature ] [ Comments ] ]
    [ [ `modular_adaptor& operator=(const modular_adaptor& o)` ] [ ] ]
    [ [ `modular_adaptor& operator=(modular_adaptor&& o)` ] [ ] ]
    [ [ `modular_adaptor& operator=(const char* s)` ] [ ] ]
]

[h4:getter Getters]
`inline Backend& base_data()`

`inline Backend const& base_data() const`

returns residue class

`inline modular_params<Backend>& mod_data()`

`inline const modular_params<Backend>& mod_data() const`

returns [link boost_multiprecision.tut.modular.modular_adaptor.modular_params `modular_params`] that contains modulus and additional data.


[h4:members Class Member Functions]

[#compare] 
[role blue `int compare(const modular_adaptor& o) const`]

Compares bases (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]) of two `modular_adaptor`.

Modulus values of the both `modular_adaptor` have to be equal. 

In other case, the functione throws the exception:
``
BOOST_THROW_EXCEPTION(std::runtime_error("Could not compare modular number with different mod."))
``

[#compare_t] 
[role blue `template <class T> int compare(const T& val) const`]

TO DO (adjust_data)

[#negate] 
[role blue `inline void negate()`]

Multiply the number by -1. 

According to the modular arithmetic rules, the result equals /modulus - number/ (always > 0).

[#str] 
[role blue `inline std::string str(std::streamsize dig, std::ios_base::fmtflags f) const`]

TO DO (adjust_data)

[#swap] 
[role blue `inline void swap(modular_adaptor& o)`]

Swap both number and modulus values between two instances of `modular_adaptor`.


[h4:other Other]
[#eval_redc] 
[role blue `template <class Backend> inline void eval_redc(Backend& result, const modular_params<Backend>& mod)`]

Computes `result` by modulo set in `modular_params`.

Currently, `modular_params` doesn't allow choosing reduction algorithm. 

By default, `modular_params` uses [@https://en.wikipedia.org/wiki/Barrett_reduction Barrett reduction] for even numbers and [@https://en.wikipedia.org/wiki/Montgomery_modular_multiplication Montgomery reduction] otherwise. 


[h4:backend_requirements Backend Required Functions]

[#eval_add] 
[role blue `template <class Backend> inline void eval_add(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]

Adds `o` base value to `result` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]). 

Modulus values of the both `modular_adaptor` have to be equal. 
The result is reduced by the modulus value.

[#eval_convert_to] 
[role blue `template <class Result, class Backend> inline void eval_convert_to(Result* result, const modular_adaptor<Backend>& val)`]

Converts a residue class handed by `modular_adapter` (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]) to the type of `result`.

Notice that modulus data (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `mod_data()`]) doesn't affect this conversion. 

[#eval_subtract] 
[role blue `template <class Backend> inline void eval_subtract(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]

Subtract `o` base value from `result` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]). 

Modulus values of the both `modular_adaptor` have to be equal. 
The result is reduced by the modulus value.

[#eval_multiply] [role blue `template <class Backend> inline void eval_multiply(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]

Multiply `o` base value to `result` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]). 

Modulus values of the both `modular_adaptor` have to be equal. 
The result is reduced by the modulus value.

[#eval_divide] [role blue `template <class Backend> inline void eval_divide(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]

Divide `result` base value by `o` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]). 

Modulus values of the both `modular_adaptor` have to be equal. 
The result is reduced by the modulus value.


[#eval_modulus] [role blue `template <class Backend> inline void eval_modulus(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& o)`]

Compute `result` base value by  modulo `o` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]).

Uses for cases then the special reduction algorithms (Montgomery or Barrett) can not be applied.

Modulus values of the both `modular_adaptor` have to be equal. 
The result is reduced by the modulus value.


[#eval_is_zero] [role blue `template <class Backend> inline bool eval_is_zero(const modular_adaptor<Backend>& val)`]

Compare `val` base value with 0.

[#eval_get_sign] [role blue `template <class Backend> inline int eval_get_sign(const modular_adaptor<Backend>&)`]

Return (int)1.

[#assign_components] [role blue `template <class Backend, class T, class V> inline void assign_components(modular_adaptor<Backend>& result, const T& a, const V& b)`]

Assign to `result` base value the value `a` and `result` mod value the value `b` in the Montgomery form (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()` and `mod_data()`] ).

[#eval_sqrt] [role blue `template <class Backend> inline void eval_sqrt(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& val)`]

Assign to `result` base value the square root of `o` base value (see [link boost_multiprecision.tut.modular.modular_adaptor.getter `base_data()`]). 

This value is not reduced on modulo.

[#eval_abs] [role blue `template <class Backend> inline void eval_abs(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& val)`]

Execute the operator `result = val`.

[#window_bits] [role blue `size_t window_bits(size_t exp_bits))`]



[#find_modular_pow] [role blue `template <class Backend> inline void find_modular_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, Backend& exp)`]



[#eval_pow] [role blue `template <class Backend> inline void eval_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, const modular_adaptor<Backend>& e)`]

[#eval_pow_backend_e] [role blue `template <class Backend> inline void eval_pow(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& b, const Backend& e)`]


[#eval_left_shift] [role blue `template <class Backend, class UI> inline void eval_left_shift(modular_adaptor<Backend>& t, UI i)`]


[#eval_right_shift] [role blue `template <class Backend, class UI> inline void eval_right_shift(modular_adaptor<Backend>& t, UI i)`]

[#eval_left_shift_with_v] [role blue `template <class Backend, class UI> inline void eval_left_shift(modular_adaptor<Backend>& t, const modular_adaptor<Backend>& v, UI i)`]

[#eval_right_shift_with_v] [role blue `template <class Backend, class UI> inline void eval_right_shift(modular_adaptor<Backend>& t, const modular_adaptor<Backend>& v, UI i)`]

[#eval_bitwise_and] [role blue `template <class Backend> inline void eval_bitwise_and(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]

[#eval_bitwise_or] [role blue `template <class Backend> inline void eval_bitwise_or(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]

[#eval_bitwise_xor] [role blue `template <class Backend> inline void eval_bitwise_xor(modular_adaptor<Backend>& result, const modular_adaptor<Backend>& v)`]

[include tutorial_modular_params.qbk]
[endsect] [/section:modular_adaptor modular_adaptor]
